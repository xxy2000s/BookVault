![图片](https://pictures.xiaxuyang.com/img/640)

# 题目整合

[袁厨的算法小屋](https://mp.weixin.qq.com/s?__biz=Mzg3NDU4MDQ3Mw==&mid=2247491485&idx=2&sn=c425ad153a6dde0c1841adbbc8869823&chksm=cecfcf0bf9b8461d0831759ca5e84435eb368bf0038b38298f1c25eacd8b551f09a0eb33106b&scene=21#wechat_redirect)

### 数组：

| 题号         | 题目             |
| :----------- | :--------------- |
| leetcode 1   | 两数之和         |
| leetcode 59  | 螺旋矩阵 II      |
| leetcode 66  | 加一             |
| 剑指offer3   | 数组中重复的数字 |
| leetcode 75  | 颜色分类         |
| leetcode 54  | 螺旋矩阵         |
| leetcode 560 | 和为K的子数组    |

### 链表：

| 题号            | 题目                     |
| :-------------- | :----------------------- |
| leetcode 21     | 合并两个有序链表         |
| leetcode 203    | 移除链表元素             |
| leetcode 206    | 反转链表                 |
| leetcode 141    | 环形链表                 |
| leetcode 86     | 分隔链表                 |
| leetcode 61     | 旋转链表                 |
| 剑指 Offer 22   | 链表中倒数第k个节点      |
| 剑指 Offer 52： | 两个链表的第一个公共节点 |

### 字符串

| 题号          | 题目               |
| :------------ | :----------------- |
| leetcode 344  | 反转字符串         |
| 剑指 Offer 05 | 替换空格           |
| leetcode 151  | 翻转字符串里的单词 |
| 剑指offer 58  | 左旋转字符串       |
| leetcode 13   | 罗马数字转整数     |
| leetcode 28   | 实现 strStr()      |

### 哈希表

| 题号               | 题目                    |
| :----------------- | :---------------------- |
| leetcode 242       | 有效的字母异位词        |
| leetcode 1207      | 独一无二的出现次数      |
| 剑指 Offer 56 - I  | 数组中数字出现的次数    |
| 剑指 Offer 56 - II | 数组中数字出现的次数 II |
| leetcode 349       | 两个数组的交集          |
| leetcode 1         | 两数之和                |
| leetcode 202       | 快乐数                  |

### 栈和队列

| 题号           | 题目                         |
| :------------- | :--------------------------- |
| leetcode 20    | 有效的括号                   |
| 剑指 Offer 09  | 用两个栈实现队列             |
| leetcode 225   | 用队列实现栈                 |
| leetcode 1047  | 删除字符串中的所有相邻重复项 |
| leetcode  1021 | 删除最外层的括号             |

### 二叉树

| 题号              | 题目                           |
| :---------------- | :----------------------------- |
| leetcode 144      | 二叉树的前序遍历               |
| leetcode 94       | 二叉树的中序遍历               |
| leetcode 145      | 二叉树的后序遍历               |
| 剑指 Offer 27     | 二叉树的镜像                   |
| 剑指 Offer 28     | 对称的二叉树                   |
| 剑指 Offer 55 - I | 二叉树的深度                   |
| 102               | 二叉树的层序遍历               |
| 404               | 左叶子之和                     |
| 129               | 求根到叶子节点数字之和         |
| 106               | 从中序与后序遍历序列构造二叉树 |
| 剑指 Offer 07     | 重建二叉树                     |
| 700               | 二叉搜索树中的搜索             |
| 98                | 验证二叉搜索树                 |
| 96                | 不同的二叉搜索树               |
| 235               | 二叉搜索树的最近公共祖先       |
| 669               | 修剪二叉搜索树                 |

### 图

| 题号 | 题目       |
| :--- | :--------- |
| 841  | 钥匙和房间 |
| 133  | 克隆图     |
| 1162 | 地图分析   |

### 双指针：

| 题号          | 题目             |
| :------------ | :--------------- |
| leetcode 27   | 移除元素         |
| leetcode  209 | 长度最小的子数组 |
| leetcode 141  | 环形链表 II      |
| leetcode 328  | 奇偶链表         |
| leetcode  15  | 三数之和         |
| leetcode  18  | 四数之和         |

### 二分查找 

| 题号               | 题目                                   |
| :----------------- | :------------------------------------- |
| leetcode 35        | 搜索插入位置                           |
| leetcode 34        | 在排序数组中查找元素的第一个和最后一个 |
| leetcode 33        | 搜索旋转排序数组                       |
| leetcode 81        | 搜索旋转排序数组 II                    |
| leetcode 153       | 寻找旋转排序数组中的最小值             |
| leetcode 74        | 搜索二维矩阵                           |
| 剑指 Offer 53 - II | 0～n-1中缺失的数字                     |

### 滑动窗口

| 题号              | 题目                 |
| :---------------- | :------------------- |
| 剑指 Offer 42     | 连续子数组的最大和   |
| 剑指 Offer 59 - I | 滑动窗口的最大值     |
| 3                 | 无重复字符的最长子串 |
| 209               | 长度最小的子数组     |
| 53                | 最大子序和           |
| 424               | 替换后的最长重复字符 |

### 贪心

| 题号 | 题目                   |
| :--- | :--------------------- |
| 455  | 分发饼干               |
| 376  | 摆动序列               |
| 53   | 最大子序和             |
| 860  | 柠檬水找零             |
| 122  | 买卖股票的最佳时机 II  |
| 134  | 加油站                 |
| 406  | 根据身高重建队列       |
| 452  | 用最少数量的箭引爆气球 |
| 56   | 合并区间               |
| 738  | 单调递增的数字         |

### 分治

| 题号          | 题目                     |
| :------------ | :----------------------- |
| 53            | 最大子序和               |
| 169           | 多数元素                 |
| 剑指 Offer 40 | 最小的k个数              |
| 215           | 数组中的第K个最大元素    |
| 23            | 合并K个升序链表          |
| 4             | 寻找两个正序数组的中位数 |

### 单调栈单调队列

| 题号               | 题目                 |
| :----------------- | :------------------- |
| 155                | 最小栈               |
| 739                | 每日温度             |
| 剑指 Offer 59 - II | 队列的最大值         |
| 剑指 Offer 59 - I  | 滑动窗口的最大值     |
| 42                 | 接雨水               |
| 496                | 下一个更大元素 I     |
| 503                | 下一个更大元素 II    |
| 1081               | 不同字符的最小子序列 |

### 位运算

| 题号          | 题目                 |
| :------------ | :------------------- |
| 136           | 只出现一次的数字     |
| 137           | 只出现一次的数字 II  |
| 260           | 只出现一次的数字 III |
| 剑指 Offer 65 | 不用加减乘除做加法   |
| 剑指 Offer 15 | 二进制中1的个数      |
| 78            | 子集                 |

### 回溯

| 题号         | 题目         |
| :----------- | :----------- |
| 77           | 组合         |
| 39           | 组合总和     |
| 40           | 组合总和 II  |
| 216          | 组合总和 III |
| 46           | 全排列       |
| 47           | 全排列 II    |
| 面试题 08.12 | 八皇后       |
| 51           | N 皇后       |

### 动态规划

| 题号 | 题目               |
| :--- | :----------------- |
| 509  | 斐波那契数         |
| 70   | 爬楼梯             |
| 746  | 使用最小花费爬楼梯 |
| 121  | 买卖股票的最佳时机 |
| 64   | 最小路径和         |
| 198  | 打家劫舍           |
| 213  | 打家劫舍 II        |
| 5    | 最长回文子串       |
| 120  | 三角形最小路径和   |

持续更新中.......



# Hot 100

## 非常不熟的...

#### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)



## 面经中的算法题

#### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
>
>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
>
>必须 原地 修改，只允许使用额外常数空间。
>

```c++
void nextPermutation(vector<int>& nums) {
        int len = nums.size()-1;
        for(int i=len;i>0;--i){
            if(nums[i]>nums[i-1]){
                for(int k=len;k>=i;--k){
                    if(nums[k]>nums[i-1]){
                        swap(nums[k], nums[i-1]);
                        break;
                    } 
                }
                sort(nums.begin()+i,nums.end());
                return;
            }
            else continue;
        }
        sort(nums.begin(),nums.end());
        return;
    }
```





## 前缀和

[参考](https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/de-liao-yi-wen-jiang-qian-zhui-he-an-pai-yhyf/)

![微信图片_20210116124856.jpg](https://pic.leetcode-cn.com/1610772571-ENbfIz-微信图片_20210116124856.jpg)

#### [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)





## 经典数组问题

#### [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

**类似题：**

>#### [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)
>
>#### [442. 数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)





## 背包问题

附上01背包问题的模版：

```dart
//01背包
for (int i = 0; i < n; i++) {
    for (int j = m; j >= V[i]; j--) {
        f[j] = max(f[j], f[j-V[i]] + W[i]);
    }
}
//完全背包
for (int i = 0; i < n; i++) {
    for (int j = V[i]; j <= m; j++) {
        f[j] = max(f[j], f[j-V[i]] + W[i]);
    }
}
```

f[j]代表当前背包容量为j的时候，可以获取的最大价值。完全背包是从左向右遍历，f[j-V[i]]取到的是拿第i个物品时的值，是新值，可以重复无限的拿，f[j]的值也会随之增加。
V：商品的体积
W：商品的价值![416.分割等和子集1](https://pictures.xiaxuyang.com/img/1611047974-CMdFek-file_1611047974684)



#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)







## 经典链表问题

#### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)





## 经典栈问题

[逆波兰表达式](https://oi-wiki.org/misc/expression/)

>后缀表达式 运算符在两个数的后面

#### [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

#### [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)

#### [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)



## 经典Hash表

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

#### [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)





## 经典树

#### [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/) （还没做）





## 经典回溯

### 组合排列

#### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/) （不是hot100）

 >给定一个字符串 *s*，将 *s* 分割成一些子串，使每个子串都是回文串。
 >
 >返回 *s* 所有可能的分割方案。

```c++
 vector<vector<string>> partition(string s) {
        vector<vector<string> > ans;
        vector<string> path;
        dfs(s, ans, path, 0);
        return ans;
    }

    void dfs(string s, vector<vector<string> >& ans, vector<string>& path, int depth){
        if(depth==s.size()){
            ans.push_back(path);
            return;
        }
        for(int i=depth;i<s.size();++i){
            if(isPalindrome(s, depth, i)){
                path.push_back(s.substr(depth, i-depth+1));
            }
            else continue;
            dfs(s, ans, path, i+1);
            path.pop_back();

        }
    }

    bool isPalindrome(const string& s, int lo, int hi){
        for(int i=lo, j=hi;i<j;++i,--j){
            if(s[i]!=s[j]) return false;
        }
        return true;
    }
```

#### [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)



## 经典字符串问题

必须掌握：

### 回文子串

#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

**经典模板**

```c++
if(s.size()<2) return s;
        int lo=0;
        int len = 1;
		//这个双重for循环就能把这个字符串的匹配情况完全写到isPalindromic这个二维dp table中
        vector<vector<bool> > isPalindromic(s.size(), vector<bool>(s.size(), false));
        for(int i=s.size();i>=0;--i){
            for(int j=i;j<s.size();++j){
                if(s[i]==s[j] && (j-i<=1 || isPalindromic[i+1][j-1])){
                    isPalindromic[i][j]=true;
                    if(len<j-i+1){
                        lo = i;
                        len = j-i+1;
                    }
                }
            }
        }
        return s.substr(lo, len);
```

#### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

#### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

#### [132. 分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)

```c++
//用131的方法的话会超时
int minCut(string s) {
        if(s.size()==0) return 0;
        vector<vector<bool> > isPalindromic(s.size(), vector<bool>(s.size(), false));
        //---------这里必须倒序来(很巧妙)
        for(int i=s.size()-1;i>=0;--i){
            for(int j=i;j<s.size();++j){
                if(s[i]==s[j] && (j-i<=1 || isPalindromic[i+1][j-1]))
                    isPalindromic[i][j]=true;
            }
        }
    	//后面就是简单动态规划了
        vector<int> dp(s.size(), 0);
        for(int i=0;i<s.size();++i) dp[i]=i;
        for(int i=1;i<s.size();++i){
            if(isPalindromic[0][i]){
                dp[i]=0;
                continue;
            } 
            for(int j=0;j<i;++j){
                if(isPalindromic[j+1][i]) dp[i] = min(dp[i], dp[j]+1);
            }
        }
        return dp[s.size()-1];
    }
```



### 字符串动态规划<高频！！！！>

#### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
>
>'.' 匹配任意单个字符
>'*' 匹配零个或多个前面的那一个元素
>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

```c++
bool isMatch(string s, string p) {
        int len1 = s.size();
        int len2 = p.size();
        //dp[i][j]表示s第i个 和p第j个 字符(包括i,j)之前是否匹配
        vector<vector<bool> > dp(len1+1, vector<bool>(len2+1, false));
        dp[0][0] = true;
        //这里很重要
        //针对匹配s为空时的特殊情况的初始化
        for(int i=0;i<p.size();++i){
            //注意对于p 输入第一个字符为'*'是不合法的 所以这里i-1肯定合法
            if(p[i]=='*') dp[0][i+1] = dp[0][i-1];
        }
        for(int i=0;i<len1;++i){
            for(int j=0;j<len2;++j){
                //如果相等或p[j]万能匹配 直接都后退一格
                if(s[i]==p[j] || p[j]=='.') dp[i+1][j+1] = dp[i][j];
                //如果为'*'则两种情况
                else if(p[j]=='*'){
                    //之前说了 对于p 输入第一个字符为'*'是不合法的 所以j>=1 后面j-1都合法
                    //如果前一格匹配
                    if(p[j-1]==s[i] || p[j-1]=='.'){
                        //dp[i+1][j-1]对应匹配零个
                        //dp[i+1][j]对应匹配一个
                        //dp[i][j+1]对应匹配多个
                        dp[i+1][j+1] = dp[i+1][j-1] || dp[i+1][j] || dp[i][j+1];
                    }
                    //对于p 前一个字符和s当前字符不匹配 则p回退两格
                    else dp[i+1][j+1] = dp[i+1][j-1];
                    
                }
                //如果p[j]不为特殊字符且与s[i]不等 则继续
                else continue;
            }
        }
        return dp[len1][len2];
    }
```

#### [132. 分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)



### 字符串与栈

**字符串问题常常和栈结合**

#### [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)

```c++
 string decodeString(string s) {
        stack<int> num_st;
        stack<string> s_st;
        int multi = 0;
        string res;
        for(auto& c:s){
            if((c-'0')>=0 && (c-'0')<=9){
                multi = multi*10 + (c-'0');
            } 
            else if(c=='['){
                //数字入栈 并清零
                num_st.push(multi);
                multi = 0;
                //字符入栈并置空
                s_st.push(res);
                res = "";
            }
            //要进行计算并更新res了
            else if(c==']'){
                multi = num_st.top();
                //这里处理字符串非常巧妙
                //-----------------核心部分-----------
                for(int i=0;i<multi;++i){
                    s_st.top()+=res; //这个循环计算  数字*字符串
                }
                res = s_st.top();
                s_st.pop();

                //更新数字
                num_st.pop();
                multi = 0;
            }
            //为字符则往后加   
            else res.push_back(c);
            
        }
        return res;
    }
```



### 字符串组合问题及切分问题（回溯）

#### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)



### 字符串分类讨论

#### [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)



## 经典排序问题

#### [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

>[参考](https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/406du-shuo-shi-tan-xin-na-yao-wei-shi-yao-yong-tan/)
>
>重写排序cmp  身高降序 位置升序
>
>按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。
>
>所以在按照身高从大到小排序后：
>
>**局部最优：**优先按身高高的people的k来插入。插入操作过后的people满足队列属性
>
>**全局最优：**最后都做完插入操作，整个队列满足题目队列属性
>
>**复习：** 动态数组vector太慢 用链表更好



## 经典贪心问题

#### [135. 分发糖果](https://leetcode-cn.com/problems/candy/)





## 经典动态规划

#### [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/) 







## 经典图问题

**图的相关算法问题要加强啊....**

![img](https://pictures.xiaxuyang.com/img/1c2294cf156a56b90a5d750b6cded3b80e92ab8821abbcb47296cc20845d162a-207-1.png)

#### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

#### [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)

```c++
const double eps = 1e-6;
    const int inf = 0x3f3f3f3f;
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        unordered_map<string, int> dir;
        //字符总数
        int cnt = 0;
        //统计equations中的字符 并且字符映射到索引 
        for(auto& e:equations){
            if(!dir.count(e[0])) dir[e[0]] = cnt++;
            if(!dir.count(e[1])) dir[e[1]] = cnt++;
        }
        //dp是权值矩阵
        vector<vector<double> > dp(cnt, vector<double>(cnt, inf));
        for(int i=0;i<cnt;++i) dp[i][i] = 1.0;
        //给路径赋双向权值
        for(int i=0;i<equations.size();++i){
            int u = dir[equations[i][0]];
            int v = dir[equations[i][1]];
            double w = values[i];
            dp[u][v] = w;
            dp[v][u] = 1/w;
        }
        //floyd算法 
        for(int k=0;k<cnt;++k){
            for(int i=0;i<cnt;++i){
                for(int j=0;j<cnt;++j){
                    //abs(dp[i][l]-inf>eps) 意即 dp[i][k]!=inf 精度要求
                    if(abs(dp[i][k]-inf)>eps && abs(dp[k][j]-inf)>eps)
                        dp[i][j] = dp[i][k]*dp[k][j];
                }
            }
            
        }
        vector<double> ans;
        for(auto& q:queries){
            //map的count计数用法 用!dir[q[0]] 则不行
            if(!dir.count(q[0]) || !dir.count(q[1])){
                ans.push_back(-1.0);
                continue;
            }
            int u = dir[q[0]];
            int v = dir[q[1]];
            if(abs(dp[u][v]-inf)>eps) ans.push_back(dp[u][v]);
            else ans.push_back(-1.0);
        }
        return ans;
    }
```



# 力扣每日一题

#### [1128. 等价多米诺骨牌对的数量](https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/)

**解题思路**

暴力的话会超时

用map统计每一张骨牌的数量（统计时先将所有骨牌翻转为nums[0]小，nums[1]大，便于建表）。
需要注意：<u>unordered_map 不支持 unordered_map<pair<int, int>, int> 或者 unordered_map<vector<int>, int></u>
<u>因为std::unordered_map底层是hash，而unordered_map没有专门的hash提供给std::pair。</u>

**参考**

```c++
 int numEquivDominoPairs(vector<vector<int>>& dominoes) {
        int cnt = 0;
        map<vector<int>, int> nums2Cnts;
        for (vector<int>& nums : dominoes) {
            //翻转骨牌
            if (nums[0] > nums[1]) {
                swap(nums[0], nums[1]);
            }
            ++nums2Cnts[nums];
            }
        for (auto& c : nums2Cnts) {
            if (c.second > 1) {
                //排列组合C(n,2)，其中n为等价骨牌的总数量。
                cnt += (c.second * (c.second - 1)) / 2;
            }
        }
        return cnt;
    }
```

**提交**

```c++
int numEquivDominoPairs(vector<vector<int>>& dominoes) {
        int ans=0;
        if(dominoes.size()==0 || dominoes[0].size()==0) return ans;
        map<vector<int>, int> dir;
        for(auto& nums : dominoes){
            if(nums[0]>nums[1]) swap(nums[0], nums[1]);
            ++dir[nums];
        }
        for(auto& c : dir){
            if(c.second>1)
            {
                ans += c.second*(c.second-1)/2;
            }
        }
        return ans;
    }
```

**思考：** 复习掌握一下map的用法 以及auto关键字和c++基础



#### [331. 验证二叉树的前序序列化](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)

[参考](https://www.hrwhisper.me/leetcode-verify-preorder-serialization-of-a-binary-tree/)



#### [705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset/)

#### [706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap/)

#### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

#### [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

#### [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

#### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

#### [73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)



#### [341. 扁平化嵌套列表迭代器](https://leetcode-cn.com/problems/flatten-nested-list-iterator/) ⭐

#### [456. 132 模式](https://leetcode-cn.com/problems/132-pattern/) ⭐

#### [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

#### [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

#### [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)



#### [664. 奇怪的打印机](https://leetcode-cn.com/problems/strange-printer/)

>
>
>cv大法

### 重要的每日一题



#### [421. 数组中两个数的最大异或值](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/)

>c基础，那些什么结构体、指针啥的一塌糊涂。
>
>字典树，有考察，经典。
