# 经典面试合集

[模板](https://blog.csdn.net/fuxuemingzhu/article/details/101900729)

| 类型       | 重要程度 | 难度 | 掌握程度 |
| :--------- | :------: | :--: | :------: |
| **1.题型** |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐  |   ⭐⭐⭐⭐   |





| 题目                                                         | 难度&重要程度 | 类型 | 练习次数 | 最后一次情况 | 完成时间 | 上次时间 |
| ------------------------------------------------------------ | :-----------: | :--: | :------: | :----------: | :------: | :------: |
| [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list) |               |      |          |              |          |          |
|                                                              |               |      |          |              |          |          |
|                                                              | ⭐💘🧡💚 && 💥✅🐴💌🔅 |  Ⅰ   |   2☑️🆗    |              |          |          |
|                                                              |    Medium     |  Ⅰ   |    1     |              |          |          |







#  算法

<img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/LCCN-Articles/explore/2018 面试汇总/lc_sum.png" alt="img" style="zoom: 50%;" />



**算法 - Algorithms**

排序算法：快速排序、归并排序、计数排序

搜索算法：回溯、递归、剪枝技巧

图论：最短路、最小生成树、网络流建模

动态规划：背包问题、最长子序列、计数问题

基础技巧：分治、倍增、二分、贪心

**数据结构 - Data Structures**

数组与链表：单 / 双向链表、跳舞链

栈与队列

树与图：最近公共祖先、并查集

哈希表

堆：大 / 小根堆、可并堆

字符串：字典树、后缀树





## 排序

![图片](https://mmbiz.qpic.cn/mmbiz/pxMrQvgWLULukLoUAiclCyTaFDNDEXic9EklctStVpG2AlyonLjKno1oEVicWp2XpynhUXyRPvGiakE4yX0pIKD8QA/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 一、快速排序



### 二、堆排



### 三、插入排序

#### [leetcode480.滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/)

```c++
//test4
//C++ upper_bound() lower_bound()
//480滑动窗口中位数
#include<iostream>
#include<algorithm>
#include<vector>
#include<unordered_map>
#include<string>
#include<deque>

using namespace std;
int main()
{
  vector<int> nums = {1,4,2,3,5,8};
  int k=5;
  vector<double> ans;
  int left=0;
  int right=k;

  deque<long long> window;
  for(int i=0;i<k;i++){
    //begin() refer to the first element
    //end() refer to the pass-the-end element
    //deque为空时 end()和begin()一样 window.end()-window.begin()=0
    //deque不为空时 为长度 
    //upper_bound没找到时 就是在wi ndow.end()的位置 同时对应的迭代器和window.end()一样为空 只有在插入操作后才有值
    deque<long long>::iterator insert_p = upper_bound(window.begin(), window.end(), nums[i]);
    cout<<(window.end()-window.begin())<<"   "<<*(insert_p)<<" "<<(insert_p-window.begin())<<endl;
    window.insert(insert_p, nums[i]);
  }
  ans.push_back((window[k/2]+window[(k-1)/2])/2.0);
  for(int i=k;i<nums.size();i++){
    deque<long long>::iterator delete_p = lower_bound(window.begin(), window.end(), nums[i-k]);
    window.erase(delete_p);

    deque<long long>::iterator insert_p = upper_bound(window.begin(), window.end(), nums[i]);
    window.insert(insert_p, nums[i]);

    ans.push_back((window[k/2]+window[(k-1)/2])/2.0);
  }
  cout<<ans[0]<<endl;
  return 0;
}

```





### 四、归并排序



### 五、冒泡排序



### 六、选择排序



## 搜索



### 一、DFS

| 类型                | 重要程度 | 难度  | 掌握程度 |
| :------------------ | :------: | :---: | :------: |
| **1.DFS+回溯+剪枝** |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ |   ⭐⭐⭐    |
| **2.DFS+树**        |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐⭐  |   ⭐⭐⭐    |
| **3.DFS+网格型**    |   ⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ |   ⭐⭐⭐    |
| **4.DFS+图**        |   ⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ |    ⭐     |





| 题目                                                         | 难度&重要程度 | 类型 | 练习次数 | 最后一次情况 | 完成时间 | 上次时间 |
| ------------------------------------------------------------ | :-----------: | :--: | :------: | :----------: | :------: | :------: |
| [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/) |     🧡&&💌      |  Ⅰ   |    1     |    看解答    |          |          |
| [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/) |     🧡&&💌      |  Ⅰ   |    1     |    看解答    |          |          |
| [46. 全排列](https://leetcode-cn.com/problems/permutations/) |     🧡&&💥      |  Ⅰ   |    1     |              |          |          |
| [78. 子集](https://leetcode-cn.com/problems/subsets/)        |     🧡&&💥      |  Ⅰ   |          |              |          |          |
| ⭐                                                            | ⭕💘🧡💚 && 💥✅🐴💌🔅 |  Ⅰ   |   2☑️🆗    |              |          |          |
|                                                              |    Medium     |  Ⅰ   |    1     |              |          |          |
|                                                              |               |      |          |              |          |          |
| [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/) 🐴 |    🧡 && 💥     |  Ⅲ   |    1     |              |          |          |
| [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/) |       🧡       |  Ⅲ   |    1     |              |          |          |



>**回溯模板题：**
>
>[剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)
>
>```c++
>vector<string> permutation(string s) {    
>        vector<string> ans;
>        dfs(s, ans, 0);
>        return ans;
>    }
>
>    void dfs(string s, vector<string>& ans, int depth){
>        if(depth>=s.size()-1) 
>        {
>            ans.push_back(s);
>            return;
>        }
>        unordered_set<char> used;
>        for(int i=depth;i<s.size();++i){
>            if(used.find(s[i]) != used.end()) continue;
>            used.insert(s[i]);
>            swap(s[depth],s[i]);
>            dfs(s, ans, depth+1);
>            swap(s[i], s[depth]);
>        }
>        
>    }
>```
>
>[46. 全排列](https://leetcode-cn.com/problems/permutations/)
>
>>给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。
>
>```c++
>//注释部分是看题解写的
>//未注释部分是按照 剑指offer38.字符串的排列 那题模板写的..
>//其实都差不多
>vector<vector<int>> permute(vector<int>& nums) {
>        vector<vector<int> > ans;
>        // vector<int> res;
>        // vector<int> used(nums.size(), 0);
>        // helper(ans, nums, res, used);
>        helper(ans, nums, 0);
>        return ans;
>    }
>
>    // void helper(vector<vector<int> >& ans,vector<int>& nums, vector<int>& res, vector<int>& used){
>    //     if(res.size()==nums.size()){
>    //         ans.push_back(res);
>    //         return;
>    //     }
>    //     for(int i=0;i<nums.size();++i){
>    //         if(used[i]!=0) continue;
>    //         else{
>    //             res.push_back(nums[i]);
>    //             used[i] = 1;
>    //             helper(ans, nums, res, used);
>    //             res.pop_back();
>    //             used[i]=0;
>    //         }
>    //     }
>    // }
>
>    void helper(vector<vector<int> >& ans,vector<int>& nums, int depth){
>        if(depth==nums.size()-1){
>            ans.push_back(nums);
>            return;
>        }
>        unordered_set<int> used;
>        for(int i=depth;i<nums.size();++i){
>            if(used.find(nums[i])!=used.end()) continue;
>            used.insert(nums[i]);
>            swap(nums[depth],nums[i]);
>            helper(ans, nums, depth+1);
>            swap(nums[depth],nums[i]);
>        }
>    }
>```
>
>







>**网格 DFS 遍历的基本框架** [参考](https://mp.weixin.qq.com/s?__biz=MzA5ODk3ODA4OQ==&mid=2648167208&idx=1&sn=d8118c7c0e0f57ea2bdd8aa4d6ac7ab7&chksm=88aa236ebfddaa78a6183cf6dcf88f82c5ff5efb7f5c55d6844d9104b307862869eb9032bd1f&token=1064083695&lang=zh_CN#rd)
>
>```C++
>void dfs(vector<vector<int> >& grid, int r, int c){
>      //base case
>      if(!inArea(grid, r, c)) return;
>      //不是岛屿 直接返回
>      if(grid[r][c]!=1) return;
>      grid[r][c] = 2;  //将格子标为遍历过
>      //对上下左右进行遍历
>      dfs(grid, r+1,c);
>      dfs(grid, r-1,c);
>      dfs(grid, r,c-1);
>      dfs(grid, r,c+1);
>    }
>
>    //判断岛屿是否在格子中
>    bool inArea(vector<vector<int> >& grid, int r, int c){
>      return 0<=r && r<grid.size() && 0<=c && c<grid[0].size;
>    } 
>```
>

>[695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)
>
>```c++
>int maxAreaOfIsland(vector<vector<int>>& grid) {
>      int ans = 0;
>      for(int i=0;i<grid.size();++i){
>        for(int j=0;j<grid[0].size();++j){
>          if(grid[i][j]==1){
>              int r=dfs(grid,i,j);
>              ans = max(ans, r);
>          }
>        }
>      }
>      return ans;
>    }
>
>    int dfs(vector<vector<int>>& grid, int r, int c){
>      //base case
>      if(!inArea(grid, r, c)) return 0;
>      //不是岛屿 直接返回
>      if(grid[r][c]!=1) return 0;
>      grid[r][c] = 2;  //将格子标为遍历过
>      //对上下左右进行遍历
>      return 1 + dfs(grid, r+1,c) + dfs(grid, r-1,c) + dfs(grid, r,c+1) + dfs(grid, r,c-1);
>    }
>
>    //判断岛屿是否在格子中
>    bool inArea(vector<vector<int>>& grid, int r, int c){
>      return 0<=r && r<grid.size() && 0<=c && c<grid[0].size();
>    } 
>```





### 二、BFS

> **层序遍历：**
>
> 「BFS 遍历」、「层序遍历」、「最短路径」实际上是递进的关系。在 BFS 遍历的基础上区分遍历的每一层，就得到了层序遍历。在层序遍历的基础上记录层数，就得到了最短路径。



### 三、二分查找

>一般用于有序数组或BST, 二分查找效率很高O(logn)



## 动态规划

大多数递归都可以用动态规划的思想重写

**递推法自底向上**

**递归法自顶向下**

![1f95da43d1bdeebdd1213bb804034ddc5f906dc61451cd63f2b5ab5d0eb33b33-「动态规划」问题思考方向](https://pictures.xiaxuyang.com/img/1f95da43d1bdeebdd1213bb804034ddc5f906dc61451cd63f2b5ab5d0eb33b33-「动态规划」问题思考方向.png)

| 类型                   | 重要程度 | 难度  | 掌握程度 |
| :--------------------- | :------: | :---: | :------: |
| **1.背包问题**         |  ⭐⭐⭐⭐⭐   |  ⭐⭐⭐  |   ⭐⭐⭐⭐   |
| **2.动态规划与数组**   |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ |   ⭐⭐⭐⭐   |
| **3.动态规划与字符串** |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ |   ⭐⭐⭐⭐   |





| 题目                                                         | 难度&重要程度 | 类型 | 练习次数 | 最后一次情况 | 完成时间 | 上次时间 |
| ------------------------------------------------------------ | :-----------: | :--: | :------: | :----------: | :------: | :------: |
| ⭐                                                            | ⭕💘💚🧡 && 💥✅🐴💌🔅 |  Ⅰ   |   2☑️🆗    |              |          |          |
| [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/) |    🧡 && 💥     |  Ⅰ   |    1     |              |          |          |
| [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/) |               |      |          |              |          |          |
| [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/) |    💚 && 💌     |      |          |              |          |          |



>附上01背包问题的模版：
>
>```dart
>//01背包
>for (int i = 0; i < n; i++) {
>    for (int j = m; j >= V[i]; j--) {
>        f[j] = max(f[j], f[j-V[i]] + W[i]);
>    }
>}
>//完全背包
>for (int i = 0; i < n; i++) {
>    for (int j = V[i]; j <= m; j++) {
>        f[j] = max(f[j], f[j-V[i]] + W[i]);
>    }
>}
>```
>
>f[j]代表当前背包容量为j的时候，可以获取的最大价值。完全背包是从左向右遍历，f[j-V[i]]取到的是拿第i个物品时的值，是新值，可以重复无限的拿，f[j]的值也会随之增加。
>V：商品的体积
>W：商品的价值
>
>![416.分割等和子集1](https://pictures.xiaxuyang.com/img/1611047974-CMdFek-file_1611047974684)



>[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)
>
>>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
>>
>>你可以对一个单词进行如下三种操作：
>>
>>- 插入一个字符
>>- 删除一个字符
>>- 替换一个字符
>
>```c++
>//使用dpTable
>//递推法自底向上
>//递归法自顶向下
>int minDistance(string word1, string word2) {
>        int m = word1.size();
>        int n = word2.size();
>        vector<vector<int> > dp (m+1, vector<int>(n+1));
>        for(int i=0;i<=m;++i) dp[i][0] = i;
>        for(int j=0;j<=n;++j) dp[0][j] = j;
>        for(int i=1;i<=m;++i){
>            for(int j=1;j<=n;++j){
>                //当前字符串相等 则双指针都前移
>                if(word1[i-1]==word2[j-1]) dp[i][j] = dp[i-1][j-1];
>                else dp[i][j] = min(min(dp[i-1][j]+1,dp[i][j-1]+1),dp[i-1][j-1]+1);
>            }
>        }
>        return dp[m][n];
>    }
>```
>
>>[参考](https://leetcode-cn.com/circle/article/rY3PIQ/)







## 基础技巧

### 二分



### 双指针

[剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)



### 滑动窗口

**总结：** **滑动窗口+双指针+hash表** （或者unordered_set）常常结合在一起

| 类型 | 重要程度 | 掌握程度 |
| ---- | :------: | :------: |
|      |          |          |
|      |          |          |
|      |          |          |



| 题目                                                         |        难度        | 练习次数 | 最后一次情况 | 完成时间 | 上次时间  |
| :----------------------------------------------------------- | :----------------: | :------: | :----------: | :------: | --------- |
| 剑指 Offer 42                                                | 连续子数组的最大和 |          |              |          |           |
| [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/) |    简单 && 同3     |   2 √    |    二次AC    |   8min   | 2021-3-11 |
| [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/) |    简单 && 经典    |    2     |    看解答    |          | 2021-3-11 |
| [剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/) |    简单 && 经典    |    1     |    看解答    |          |           |
| [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) |   简单 && HOT100   |   2 √    |    一次AC    |  10min   | 2021-3-11 |
| [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/) |   中等 && HOT100   |    2     |    看解答    |          | 2021-3-11 |
| 209                                                          |  长度最小的子数组  |          |              |          |           |
| [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/) |        中等        |    1     |              |          |           |
| [480. 滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/) |        困难        |    1     |    看解答    |          |           |
| [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/) |        简单        |    2     |      ac      |          |           |





>[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)
>
>>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
>>
>>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。
>>
>>**示例 1：**
>>
>>```
>>输入：s = "ADOBECODEBANC", t = "ABC"
>>输出："BANC"
>>```
>



> **滑动窗口思想：**

> [总结(Conclusion)](https://blog.csdn.net/qq_43152052/article/details/102840715)
>
> ①窗口由两个指针构成，一个左指针left，一个右指针right，然后[left,right]表示的索引范围是一个窗口了。
>
> ②右指针right的功能是用来扩展窗口：当窗口内的条件没有达到题目要求时，我们需要不断移动右指针right直到窗口内的条件第一次满足题目要求为止。
>
> ③左指针left的功能是用来缩小窗口的：当窗口内的条件已满足题目条件或多于题目条件时（窗口溢出），我们缩小窗口，也就是左指针left需要右移直到窗口条件不满足为止。这时，我们需要记录当前窗口的大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针right，使得窗口满足题目的条件。
>
> 注：滑动窗口用来处理连续满足一定条件的连续区间的性质（长度等）问题的，两个指针都起始于原点，并一前一后向终点前进。

> **框架**
>
> ```c++
> func movingWindow() {
>     /* 1. 初始化窗口数据结构，用于记录窗口内的信息 */
>     first, last := 0, 0    // 窗口的左右边界
>     for last < len(s) {
>         /* 2. 把 last 指向的元素加入窗口 */
>         for first < len(s) && /* 3. 判断当前窗口内的元素是否符合条件 */ {
>             /* 4.a 在这写更新窗口最小值的代码 */
>             /* 5. 把 first 指向的元素移出窗口 */
>             first++
>         }
>         /* 4.b 在这写更新窗口最大值的代码 */
>         last++
>     }
> }
> ```



>[leetcode480.滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/)
>
>>这里我们使用multiset来求出中位数（因为multiset底层使用的是二叉搜索树BST的数据结构，插入和删除元素的时间复杂度为O(logn)），利用multiset的自排序功能可以很快求出中位数。multiset作为大小为k的滑动窗口，每次插入新插入元素，需将窗口移动。若新插入的元素小于mid指向的元素，则需要将mid左移（因为新插入的元素比中位数小，那么中位数肯定会被拉低）；插入一个元素后，我们也需要删除一个元素，若需要删除的元素小于mid指向的元素，那么我们应该将mid右移。注意：对于删除元素，我们不能使用erase根据value来删除，因为这样会删除多个值一样的元素，所以我们应该使用lower_bound来找到第一个不小于目标值的数，通过iterator来删掉确定的一个数字。
>>关于next()与prev()函数的解释：[Here](https://blog.csdn.net/qq_43152052/article/details/102610540)
>
>```c++
>//480滑动窗口中位数
>class Solution {
>public:
>      vector<double> medianSlidingWindow(vector<int>& nums, int k) {
>      vector<double> ans;
>      if(nums.size()==0) return ans;
>      int left=0;
>      int right=k;
>      //由于可能testcase [2147483647,2147483647] k=2
>      //发生溢出 所以window设置为long long类型
>      deque<long long> window;
>
>      //插入排序
>      //通过upper_bound lower_bound(底层都是二分法实现)产生一个迭代器
>      //lower_bound准确找到该删的节点 upper_bound找到该插入的节点
>      for(int i=0;i<k;i++){
>        deque<long long>::iterator insert_p = upper_bound(window.begin(), window.end(), nums[i]);
>        //deque的insert要传迭代器和val。
>        window.insert(insert_p, nums[i]);
>      }
>
>      //ans为double类型 除以2.0使long long变为double
>      ans.push_back((window[k/2]+window[(k-1)/2])/2.0);
>      for(int i=k;i<nums.size();i++){
>        deque<long long>::iterator delete_p = lower_bound(window.begin(), window.end(), nums[i-k]);
>        //erase会删除多个同值的 所以必须传元素的迭代器。
>        window.erase(delete_p);
>
>        deque<long long>::iterator insert_p = upper_bound(window.begin(), window.end(), nums[i]);
>        window.insert(insert_p, nums[i]);
>
>        ans.push_back((window[k/2]+window[(k-1)/2])/2.0);
>      }
>      return ans;
>    }
>};
>```



### 前缀和

[参考](https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/de-liao-yi-wen-jiang-qian-zhui-he-an-pai-yhyf/)

![微信图片_20210116124856.jpg](https://pic.leetcode-cn.com/1610772571-ENbfIz-微信图片_20210116124856.jpg)

| 题目                                                         | 难度&重要程度 | 类型 | 练习次数 | 最后一次情况 | 完成时间 | 上次时间 |
| ------------------------------------------------------------ | :-----------: | :--: | :------: | :----------: | :------: | :------: |
| [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/) |               |      |          |              |          |          |
|                                                              |               |      |          |              |          |          |
|                                                              | ⭐💘🧡💚 && 💥✅🐴💌🔅 |  Ⅰ   |   2☑️🆗    |              |          |          |
|                                                              |    Medium     |  Ⅰ   |    1     |              |          |          |



### 分治



### 贪心



### 单调栈



## 思维题

### 矩阵相关

| 题目                                                         | 难度 | 练习次数 | 最后一次情况 | 完成时间 | 上次时间  |
| :----------------------------------------------------------- | :--: | :------: | :----------: | :------: | :-------: |
| [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/) | 中等 |   2 √    |    一次ac    |  10min   | 2021-3-15 |
| [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/) | 简单 |   2 √    |    一次ac    |   8min   | 2021-3-16 |



#### [面试题 01.07. 旋转矩阵](https://leetcode-cn.com/problems/rotate-matrix-lcci/)

>给你一幅由 `N × N` 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。
>
>不占用额外内存空间能否做到？
>
><u>旋转270°是转置。旋转180°是先上下对称，再左右对称。旋转90°是先转置,然后左右对称过去。</u>
>
>**相同题：**[48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

#### [面试题 01.08. 零矩阵](https://leetcode-cn.com/problems/zero-matrix-lcci/)

>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

#### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

>给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

#### [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

>在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。



### 数学问题

#### [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

#### [470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

>(randx()-1)Y + randx() 能随机生成[1,x*Y]内的随机数



## 位运算

>**位运算知识点：**
>
>

| 题目                                                         | 难度&重要程度 | 类型 | 练习次数 | 最后一次情况 | 完成时间 | 上次时间  |
| ------------------------------------------------------------ | :-----------: | :--: | :------: | :----------: | :------: | :-------: |
| [剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/) ⭐ |    🧡 && 💌     |      |          |              |          |           |
| [剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/) |    💚 && 💌     |      |          |              |          |           |
| [78. 子集](https://leetcode-cn.com/problems/subsets/)        |    🧡 && 💥     |      |    2☑️    |      ac      |   5min   | 2021-3-19 |
| [169. 多数元素](https://leetcode-cn.com/problems/majority-element/) |    💚 && 💥     |      |   2☑️🆗    |      ac      |   2min   | 2021-3-19 |
| [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/) ✅ |    💚 && 💥     |      |   2☑️🆗    |      ac      |   1min   | 2021-3-19 |
| [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/) |    💚 && 💥     |      |   2☑️🆗    |      ac      |   2min   | 2021-3-19 |
| [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/) |    💚 && 💥     |      |   2☑️🆗    |      ac      |   2min   | 2021-3-19 |





## 设计题

| 题目                                                         | 难度&重要程度 | 类型 | 练习次数 | 最后一次情况 | 完成时间 | 上次时间 |
| ------------------------------------------------------------ | :-----------: | :--: | :------: | :----------: | :------: | :------: |
| [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/) 🐴⭐ |    🧡 && 💥     |      |    1     |              |          |          |
| [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/) |    🧡 && 💥     |      |    1     |              |          |          |





# 数据结构

## 1.数组

| 类型       | 重要程度 | 难度  | 掌握程度 |
| :--------- | :------: | :---: | :------: |
| **1.Nsum** |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ |   ⭐⭐⭐    |





| 题目                                                         |      难度&重要程度      | 类型 | 练习次数 | 最后一次情况 | 完成时间 | 上次时间 |
| ------------------------------------------------------------ | :---------------------: | :--: | :------: | :----------: | :------: | :------: |
| [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/) | ⭕💘🧡💚 && 💥Easy && TOP✅🐴💌 |  Ⅰ   |   2☑️🆗    |              |          |          |
|                                                              |         Medium          |  Ⅰ   |    1     |              |          |          |



## 2.链表

**总结：** 

> 1.了解链表的数据结构，以及自己定义链表
>
> 2.学会使用dummyHead 这样能很好处理边界情况。删除链表节点的题型中尤为典型如：19、203
>
> 3.**删除链表节点**类型的题目一定要记得释放节点内存。否则会有内存泄漏。 如82、83

```c++
/** 
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
```



| 类型               | 重要程度 | 难度  | 掌握程度 |
| :----------------- | :------: | :---: | :------: |
| **1.反转链表**     |  ⭐⭐⭐⭐⭐   |  ⭐⭐⭐  |   ⭐⭐⭐⭐   |
| **2.回文链表**     |  ⭐⭐⭐⭐⭐   |  ⭐⭐⭐  |   ⭐⭐⭐⭐   |
| **3.链表节点删除** |  ⭐⭐⭐⭐⭐   |  ⭐⭐⭐  |   ⭐⭐⭐⭐   |
| **4.合并升序链表** |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ |   ⭐⭐⭐⭐   |
| **5.排序链表**     |   ⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ |   ⭐⭐⭐    |
| **6.环形链表**     |  ⭐⭐⭐⭐⭐   |  ⭐⭐⭐  |   ⭐⭐⭐⭐   |
| **7.链表数据结构** |   ⭐⭐⭐⭐   | ⭐⭐⭐⭐  |   ⭐⭐⭐    |
| **8.链表运算**     |   ⭐⭐⭐⭐   | ⭐⭐⭐⭐  |   ⭐⭐⭐    |



| 题目                                                         |  难度&重要程度   | 类型 | 练习次数 |    最后一次情况    | 完成时间 | 上次时间  |
| ------------------------------------------------------------ | :--------------: | :--: | :------: | :----------------: | :------: | :-------: |
| [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) |  Easy && TOP✅🐴   |  Ⅰ   |    2     |   （迭代与递归）   |          |           |
| [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/) |      Medium      |  Ⅰ   |    1     | ac(边界调试了一会) |  15min   | 2021-3-18 |
| [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/) |      Medium      |  Ⅰ   |    1☑️    |         ac         |  30min   | 2021-3-18 |
| [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/) |  Easy && HOT100  |  Ⅱ   |    2☑️    |         ac         |          |           |
|                                                              |                  |      |          |                    |          |           |
| [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/) |  Easy && HOT100  |  Ⅲ   |    2☑️    |         ac         |   5min   | 2021-3-18 |
| [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/) |       Med        |  Ⅲ   |    1☑️    |         ac         |  10min   | 2021-3-18 |
| [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/) |       Easy       |  Ⅲ   |    1☑️    |         ac         |   3min   | 2021-3-18 |
| [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) |  Easy && HOT100  |  Ⅳ   |    2☑️    |         ac         |   5min   | 2021-3-10 |
| [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)⭐ |  Hard && HOT100  |  Ⅳ   |    1     |         ac         |          |           |
|                                                              |                  |      |          |                    |          |           |
| [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)⭐ | Medium && HOT100 |  Ⅴ   |    1     |       看解答       |   ...    |    ...    |
| [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/) |  Easy && HOT100  |  Ⅵ   |    2☑️    |         ac         |   2min   | 2021-3-18 |
| [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/) | Medium && HOT100 |  Ⅵ   |    2☑️    |         ac         |   5min   |           |
| [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)  (同offer52) |  Easy && HOT100  |  Ⅵ   |    2☑️    |         ac         |          |           |
|                                                              |                  |      |          |                    |          |           |
| [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)⭐ |    剑指offer     |  Ⅶ   |    1     |       看解答       |          |           |
|                                                              |                  |      |          |                    |          |           |
| [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)⭐ |  Med && HOT100   |  Ⅷ   |    1     |         ac         |          |           |
| [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/) |       Med        |  Ⅷ   |    1     |         ac         |  20min   | 2021-3-18 |
|                                                              |                  |      |          |                    |          |           |



## 3.字符串

**字符串能动归的别回溯，容易超时**

| 类型                                | 重要程度 | 掌握程度 |
| :---------------------------------- | :------: | :------: |
| **1.字符串+动态规划**               |  ⭐⭐⭐⭐⭐   |   ⭐⭐⭐    |
| **2.回文子串**                      |  ⭐⭐⭐⭐⭐   |   ⭐⭐⭐⭐   |
| **3.字符串+栈**                     |   ⭐⭐⭐⭐   |   ⭐⭐⭐    |
| **4.字符串+回溯（组合及切分问题）** |  ⭐⭐⭐⭐⭐   |   ⭐⭐⭐    |
| **5.字符串+分类讨论**               |  ⭐⭐⭐⭐⭐   |   ⭐⭐⭐    |



| 题目                                                         | 难度&重要程度  | 类型 | 练习次数 | 最后一次情况 | 完成时间 | 上次时间 |
| ------------------------------------------------------------ | :------------: | :--: | :------: | :----------: | :------: | :------: |
| [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/) | Hard && Hot100 |  Ⅰ   |    1     |    看解答    |   ...    |   ...    |
| [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/) | Hard && Hot100 |  Ⅰ   |    1     |    看解答    |          |          |
| [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/) |     Medium     |  Ⅰ   |    1     | 回溯超时...  |          |          |
|                                                              |                |      |          |              |          |          |
|                                                              |                |      |          |              |          |          |
| [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/) |     Medium     |  Ⅱ   |    2☑️    |    一次ac    |  10min   |          |
| [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/) |      Hard      |  Ⅱ   |    1     |    看解答    |          |          |
| [132. 分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/) |  Hard && 出过  | Ⅰ&&Ⅱ |    1     |    一次ac    |          |          |
| [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/) |     Medium     |  Ⅱ   |    1     |    一次ac    |          |          |
|                                                              |                |      |          |              |          |          |
|                                                              |                |      |          |              |          |          |
|                                                              |                |      |          |              |          |          |
| [剑指 Offer 67. 把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/) |     Medium     |  Ⅴ   |    1     |      ac      |  45min   |          |
| [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/) |     Medium     | Ⅲ&&Ⅴ |    1     |    看解答    |          |          |
|                                                              |                |      |          |              |          |          |
|                                                              |                |      |          |              |          |          |
|                                                              |                |      |          |              |          |          |



| 字符串排序 |                          单词查找树                          |                    子字符串查找<KMP算法>                     | 正则表达式 | 数据压缩 | 字典树 | 前缀(后缀)树 |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--------: | :------: | ------ | ------------ |
|            | [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/) | [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/) |            |          |        |              |
|            | [30. 串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/) | [面试题 01.09. 字符串轮转](https://leetcode-cn.com/problems/string-rotation-lcci/) |            |          |        |              |
|            |                                                              |   [KMP](https://mp.weixin.qq.com/s/Gk9FKZ9_FSWLEkdGrkecyg)   |            |          |        |              |



>[567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)
>
>给定两个字符串 **s1** 和 **s2**，写一个函数来判断 **s2** 是否包含 **s1** 的排列。
>
>换句话说，第一个字符串的排列之一是第二个字符串的子串。
>
>**类似题：**
>
>[面试题 01.09. 字符串轮转](https://leetcode-cn.com/problems/string-rotation-lcci/)
>
>>字符串轮转。给定两个字符串`s1`和`s2`，请编写代码检查`s2`是否为`s1`旋转而成（比如，`waterbottle`是`erbottlewat`旋转后的字符串）。
>>
>>**解题思路：**新定义ss=s2+s2;然后判断s1是否是ss子串(暴力或KMP或自带api)
>
>[30. 串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)
>
>>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
>>
>>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。
>>





## 4.栈与队列

| 类型             | 重要程度 | 难度 | 掌握程度 |
| :--------------- | :------: | :--: | :------: |
| **1.设计题**     |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐  |   ⭐⭐⭐⭐   |
| **2.栈与字符串** |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐⭐ |   ⭐⭐⭐⭐   |

| 题目                                                         | 难度&重要程度 | 类型 | 练习次数 | 最后一次情况 | 完成时间 | 上次时间 |
| ------------------------------------------------------------ | :-----------: | :--: | :------: | :----------: | :------: | :------: |
| [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)⭐ |   💚 && 💥&&💌   |  Ⅰ   |   2☑️🆗    |              |          |          |
| [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/) 🐴 | 💚 && 💥&&💌&&🐴  |  Ⅰ   |   2☑️🆗    |              |          |          |
| [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/) |    💚 && 💌     |  Ⅰ   |          |              |          |          |
| [剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/) |    🧡 && 💌     |  Ⅰ   |          |              |          |          |
|                                                              |               |      |          |              |          |          |
| [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/) |               |      |          |              |          |          |
| [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/) |               |      |          |              |          |          |
| [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/) |               |      |          |              |          |          |



>[逆波兰表达式](https://oi-wiki.org/misc/expression/)
>
>>后缀表达式 运算符在两个数的后面



## 5.树

**总结：**二叉树题目与**递归、四种遍历和DFS搜索**相关性非常大。同时很多题目要求**迭代和递归**两种方法

| 类型                   | 重要程度 | 难度  | 掌握程度 |
| :--------------------- | :------: | :---: | :------: |
| **1.二叉树的四种遍历** |  ⭐⭐⭐⭐⭐   |  ⭐⭐⭐  |   ⭐⭐⭐⭐   |
| **2.二叉树与递归**     |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ |   ⭐⭐⭐⭐   |
| **3.二叉树与搜索DFS**  |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ |   ⭐⭐⭐    |
| **4.二叉树序列化**     |   ⭐⭐⭐⭐   | ⭐⭐⭐⭐  |   ⭐⭐⭐    |
| **5.二叉树与动态规划** |   ⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ |   ⭐⭐⭐    |



| 题目                                                         |       难度        | 类型 | 练习次数 |  最后一次情况  | 完成时间 | 上次时间  |
| ------------------------------------------------------------ | :---------------: | :--: | :------: | :------------: | :------: | :-------: |
| [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) ✅ |      💚 && 💥       |  Ⅰ   |    1☑️    |                |          |           |
| [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)  ✅ |      💚 && 💥       |  Ⅰ   |    1     |                |          |           |
| [98.验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/description/) ✅ |      💚 && 💥       |  Ⅰ   |    2☑️    |       ac       |  10min   | 2021-3-18 |
| [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/) |      💚 && 💥       |  Ⅱ   |    1☑️    |       ac       |          |           |
| [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/) |    💚 && 💥 &&💌     |  Ⅱ   |    2     | ac(递归+迭代)  |  10min   | 2021-3-18 |
|                                                              |                   |      |          |                |          |           |
|                                                              |                   |      |          |                |          |           |
| [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)⭐ |        Med        |  Ⅲ   |    1     |     看解答     |          |           |
| [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/) |         💘         |  Ⅲ   |    1     |                |          |           |
| [剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/) ⭐ |    💘 && 💥 &&💌     |  Ⅳ   |    1     |     看解答     |   ...    |           |
| [331. 验证二叉树的前序序列化](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/) ⭐ | 🧡 && 类似offer 37 |  Ⅳ   |    1     | 看解答(不太会) |   ...    | 2021-3-12 |
| [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)⭐ |         🧡         |  Ⅴ   |    1     |                |          |           |
|                                                              |                   |      |          |                |          |           |



| 莫里斯遍历 | 二叉搜索树 | 平衡二叉树 |
| :--------: | :--------: | :--------: |
|            |            |            |

>**莫里斯遍历:**用递归和迭代的方式都使用了辅助的空间，而莫里斯遍历的优点是没有使用任何辅助空间。缺点是改变了整个树的结构。
>
>**二叉搜索树：**
>
>> - 查找
>> - 插入
>> - 建树
>> - 删除

>## 递归
>
>**若非尾递归，递归会消耗O(logn)的空间，会在内存中保留O(logn)的堆栈帧。**
>
>**一般能用递归写的都能用动态规划重写。而且在数学相关问题中，递归非常容易超时。**
>
>[95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)
>
>```c++
>vector<TreeNode*> generateTrees(int n) {
>      if(n == 0) return vector<TreeNode*>(0);  //为0则返回一个空的向量
>      return helper(1, n);//
>    }
>
>    vector<TreeNode*> helper(int start, int end){
>      vector<TreeNode*> ans;
>      if(start>end){
>        ans.push_back(NULL);  //一定要push一个NULL进去 这样size至少为1 否则后面的两层for循环在一个为空的情况下无法继续
>        return ans;
>      }
>      for(int i=start;i<=end;++i){   //i代表不同的值做根节点
>      vector<TreeNode*> lefts = helper(start, i-1);  //左子树集合
>      vector<TreeNode*> rights = helper(i+1, end);   //右子树集合
>          //下面的两层for循环就是左子树与右子树的所有组合情况
>        for(int k=0;k<lefts.size();k++){   //遍历左子树集合 
>          for(int j=0;j<rights.size();j++){  //遍历右子树集合
>            TreeNode* root = new TreeNode(i);  //创建一个当前值的根节点
>            root->left = lefts[k];   //选取左子树集合中的一个作为左子树
>            root->right = rights[j];  //选取右子树集合中的一个作为右子树
>            ans.push_back(root);  //将当前的树添加到结果中
>          }
>        }
>      }
>      return ans;
>    }
>```
>



**99.恢复二叉搜索树**

```c++
//要求O(1)空间 只能Morris遍历
void recoverTree(TreeNode* root) {
      bool flag = false;
      TreeNode* rt = root;
      stack<TreeNode*> S;
      TreeNode* pre = NULL;  //定义一个野指针时一定要声明是NULL TM的被这个搞了一下午 操操操
      TreeNode* fi = NULL;
      
      while(rt || !S.empty()){
        if(rt != NULL){
          S.push(rt);
          rt = rt->left;
        }
        else{
          rt = S.top();
          S.pop();
          if(pre!=NULL)
          {
             //第一个要交换的节点 他的值小于前一个节点的值。
            if(flag == false && pre->val >= rt->val)
            {
              flag = true;
              fi = pre;
            }
              //flag为true则说明找到了第一个节点 第二个要找的节点满足以下一点
              //1.要么他的后一个节点值大于找到的第一个节点的值
              //2.要么他已经是最后一个节点了 退出while循环直接交互即可
            if(flag == true && rt->val > fi->val)
            {
              swap(fi->val,pre->val);
              return;
            }
          }
          pre = rt;
          rt = rt->right;
        }
      }
      swap(fi->val,pre->val);
      return;
    }
```



>#### 卡特兰数
>
>**公式：** *G*(*n*)=*G*(0)∗*G*(*n*−1)+*G*(1)∗*G*(*n*−2)+...+*G*(*n*−1)∗*G*(0)
>
>适用问题：
>
>n对括号正确匹配数目
>
>凸多边形三角划分
>
>出栈次序 
>
>矩阵连乘括号化：矩阵连乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案。（ h(n) 种）

**96.不同的二叉搜索树**

```c++
//转化为一个数学问题。就是求卡特兰数
int numTrees(int n) {
        vector<int> dp(n+1);
        dp[0] = 1;
        dp[1] = 1;
        for(int i=2;i<n+1;++i)
          for(int j=0;j<i;++j)
            dp[i] += dp[j]*dp[i-1-j];
        return dp[n];
    }
```



## 6.图

**总结：图的相关算法问题要加强啊....**

![img](https://pictures.xiaxuyang.com/img/1c2294cf156a56b90a5d750b6cded3b80e92ab8821abbcb47296cc20845d162a-207-1.png)

>[207. 课程表](https://leetcode-cn.com/problems/course-schedule/)
>
>[399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)
>
>```c++
>const double eps = 1e-6;
>    const int inf = 0x3f3f3f3f;
>    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
>        unordered_map<string, int> dir;
>        //字符总数
>        int cnt = 0;
>        //统计equations中的字符 并且字符映射到索引 
>        for(auto& e:equations){
>            if(!dir.count(e[0])) dir[e[0]] = cnt++;
>            if(!dir.count(e[1])) dir[e[1]] = cnt++;
>        }
>        //dp是权值矩阵
>        vector<vector<double> > dp(cnt, vector<double>(cnt, inf));
>        for(int i=0;i<cnt;++i) dp[i][i] = 1.0;
>        //给路径赋双向权值
>        for(int i=0;i<equations.size();++i){
>            int u = dir[equations[i][0]];
>            int v = dir[equations[i][1]];
>            double w = values[i];
>            dp[u][v] = w;
>            dp[v][u] = 1/w;
>        }
>        //floyd算法 
>        for(int k=0;k<cnt;++k){
>            for(int i=0;i<cnt;++i){
>                for(int j=0;j<cnt;++j){
>                    //abs(dp[i][l]-inf>eps) 意即 dp[i][k]!=inf 精度要求
>                    if(abs(dp[i][k]-inf)>eps && abs(dp[k][j]-inf)>eps)
>                        dp[i][j] = dp[i][k]*dp[k][j];
>                }
>            }
>            
>        }
>        vector<double> ans;
>        for(auto& q:queries){
>            //map的count计数用法 用!dir[q[0]] 则不行
>            if(!dir.count(q[0]) || !dir.count(q[1])){
>                ans.push_back(-1.0);
>                continue;
>            }
>            int u = dir[q[0]];
>            int v = dir[q[1]];
>            if(abs(dp[u][v]-inf)>eps) ans.push_back(dp[u][v]);
>            else ans.push_back(-1.0);
>        }
>        return ans;
>    }
>```
>
>





## 7.Hash

**总结：Hash常与双指针和滑动窗口组合。在字符串或者数组中尤为常见。**

> unordered_map查询才是O(1) map查询是O(logn)

| 类型                        | 重要程度 | 难度 | 掌握程度 |
| :-------------------------- | :------: | :--: | :------: |
| **1.Hash与字符串**          |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐  |   ⭐⭐⭐⭐   |
| **2.Hash与数组**            |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐⭐ |   ⭐⭐⭐⭐   |
| **3.Hash与双指针/滑动窗口** |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐⭐ |   ⭐⭐⭐⭐   |
| **4.Hash设计**              |   ⭐⭐⭐    | ⭐⭐⭐  |   ⭐⭐⭐    |





| 题目                                                         | 难度&重要程度 | 类型  | 练习次数 | 最后一次情况 | 完成时间 | 上次时间  |
| ------------------------------------------------------------ | :-----------: | :---: | :------: | :----------: | :------: | :-------: |
| [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) 🐴 |  🧡 && 💥 &&💌   |   Ⅰ   |   2☑️🆗    |      ac      |          |           |
| [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/) |    🧡 && 💥     |   Ⅰ   |    1     |              |          |           |
| [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/) ⭐ |    💘 && 💥     | Ⅰ&& Ⅲ |    2     |    看解答    |          |           |
|                                                              |               |       |          |              |          |           |
| [705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset/) |    💚 && 🔅     |       |    1     |    看解答    |   5min   | 2021-3-13 |
| [706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap/) |    💚 && 🔅     |       |    1     |    两次ac    |  10min   | 2021-3-14 |



## 8.堆

| 类型       | 重要程度 | 难度 | 掌握程度 |
| :--------- | :------: | :--: | :------: |
| **1.题型** |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐  |   ⭐⭐⭐⭐   |





| 题目                                                         | 难度&重要程度 | 类型 | 练习次数 | 最后一次情况 | 完成时间 | 上次时间 |
| ------------------------------------------------------------ | :-----------: | :--: | :------: | :----------: | :------: | :------: |
| [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/) |     🧡&&💌      |      |          |              |          |          |
| [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/) |     💘&&💌      |      |          |              |          |          |
| [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/) |     🧡&&💥      |      |          |              |          |          |
| [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/) |     🧡&&💥      |      |          |              |          |          |
| ⭐                                                            | ⭕💘🧡💚 && 💥✅🐴💌🔅 |  Ⅰ   |   2☑️🆗    |              |          |          |
|                                                              |    Medium     |  Ⅰ   |    1     |              |          |          |



## 9.并查集

| 类型       | 重要程度 | 难度 | 掌握程度 |
| :--------- | :------: | :--: | :------: |
| **1.题型** |  ⭐⭐⭐⭐⭐   | ⭐⭐⭐  |   ⭐⭐⭐⭐   |





| 题目 | 难度&重要程度 | 类型 | 练习次数 | 最后一次情况 | 完成时间 | 上次时间 |
| ---- | :-----------: | :--: | :------: | :----------: | :------: | :------: |
| ⭐    | ⭕💘🧡💚 && 💥✅🐴💌🔅 |  Ⅰ   |   2☑️🆗    |              |          |          |
|      |    Medium     |  Ⅰ   |    1     |              |          |          |



# 经验积累

## 模板

[模板](https://blog.csdn.net/fuxuemingzhu/article/details/101900729)

## IO处理



**总结：可以看看C++输入输出处理 尤其是stringstream 和 getline等用法**

>[331. 验证二叉树的前序序列化](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)

[C++:cin、cin.getline()、getline()的用法](https://blog.csdn.net/u011630575/article/details/79721024)

>当 cin 读取数据时，它会传递并忽略任何前导白色空格字符（空格、制表符或换行符）。一旦它接触到第一个非空格字符即开始阅读，当它读取到下一个空白字符时，它将停止读取。
>
>**getline函数可读取整行，包括前导和嵌入的空格，并将其存储在字符串对象中。**
>
>getline(cin,'\n'); cin为输入流 '\n'为结束符
>
>也可写作getline(str, tmp, ',') 就是输入字符串为str, 接受的字符串变量为tmp 。','为结束符 这样可以方便实现C++中没有的split方法



## C++语法

C++ Lambda表达式  [参考](https://www.cnblogs.com/DswCnblog/p/5629165.html)

auto 关键字  [参考](https://blog.csdn.net/xiaoquantouer/article/details/51647865)



## 递归

**若非尾递归，递归会消耗O(logn)的空间，会在内存中保留O(logn)的堆栈帧。**

**一般能用递归写的都能用动态规划重写。而且在数学相关问题中，递归非常容易超时。**



## 7个字母数字判断相关的函数

例125.[验证回文串](https://leetcode-cn.com/problems/valid-palindrome/solution/9877-ci-ti-mu-de-shou-xi-7ge-zi-mu-shu-zi-pan-duan/)
记一笔 c++的几个内置函数

islower(char c) 是否为小写字母
isupper(char c) 是否为大写字母
isdigit(char c) 是否为数字
isalpha(char c) 是否为字母
isalnum(char c) 是否为字母或者数字
toupper(char c) 字母小转大
tolower(char c) 字母大转小



## TIPs

- 长度为k的有序向量的**中位数求法**：无论奇偶,都是( num[k/2]+num[(k-1)/2])/2 也即**索引为(size-1)/2和size/2处值和的平均**

- **中间的数mid**一般为k/2,k为偶数时为偏后的那一个中间数

- **一些初始化方法**：multiset<double> window(nums.begin(),nums.begin()+k);

- **创建iterator对象**。如 

  - ```c++
    vector<int> a(20,1);
    vector<int>::iterator tmp = upper_bound(a.begin(), a.end(), val;
    ```

- 容器适配器 stack、queue 和 priority_queue 没有迭代器

- 尾递归(*tail-recursive*)：进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。

  >function story() {
  >从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story() // 尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。
  >}
  >
  >function story() {
  >从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story()，小和尚听了，找了块豆腐撞死了 // 非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。
  >}

  

string加法用“+”很耗时 用append()和push_back()方法更好

**传引用速度要快很多**



**字符串**

tmp.substr(start, num)

tmp.erase(tmp.size()-word.size()-1, word.size()+1);

删除倒数k个元素

tmp.erase(tmp.size()-k, k)



**递推法自底向上**

**递归法自顶向下**



## 常用函数：

```c++
//range [first,last)
//parameters (first, last, val)
//return iterator
lower_bound(); //first position that not less than the value
upper_bound(); //first position that greater than the value

// lower_bound/upper_bound example
#include <iostream>     // std::cout
#include <algorithm>    // std::lower_bound, std::upper_bound, std::sort
#include <vector>       // std::vector

int main () {
  int myints[] = {10,20,30,30,20,10,10,20};
  std::vector<int> v(myints,myints+8);           // 10 20 30 30 20 10 10 20

  std::sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30

  std::vector<int>::iterator low,up;
  low=std::lower_bound (v.begin(), v.end(), 20); //          ^
  up= std::upper_bound (v.begin(), v.end(), 20); //                   ^

  std::cout << "lower_bound at position " << (low- v.begin()) << '\n';
  std::cout << "upper_bound at position " << (up - v.begin()) << '\n';

  return 0;
}
```

## 算法资源

[LeetBook](https://leetcode-cn.com/leetbook/) + [Top100](https://leetcode-cn.com/problemset/leetcode-hot-100/) + [公司专题](https://leetcode-cn.com/company/bytedance/discuss/latest) + [剑指offer](https://leetcode-cn.com/problemset/lcof/) + [面试金典](https://leetcode-cn.com/problemset/lcci/) + 牛客

力扣加加	算法模板插件

算法笔记+算法4+左程云最优解

PAT labuladong AcWing

